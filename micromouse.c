#pragma config(Sensor, S1,     Ultrasonic,     sensorSONAR)
#pragma config(Sensor, S2,     Ultrasonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     Ultrasonic,     sensorSONAR)
#pragma config(Motor,  motorA,          right,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          left,          tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MAX_PEG_SIZE 81

#define isEmpty(X)    (X->size == 0)
#define isFull(X)     (X->size == MAX_PEG_SIZE)

int Ultra_L = 0 , state_L = 0;
int Ultra_R = 0 , state_R = 0;
int Ultra_F = 0 , state_F = 0;

int maze[9][9] = {  { 8,7,6,5,4,5,6,7,8 },
										{ 7,6,5,4,3,4,5,6,7 },
										{ 6,5,4,3,2,3,4,5,6 },
										{ 5,4,3,2,1,2,3,4,5 },
										{ 4,3,2,1,0,1,2,3,4 },
										{ 5,4,3,2,1,2,3,4,5 },
										{ 6,5,4,3,2,3,4,5,6 },
										{ 7,6,5,4,3,4,5,6,7 },
										{ 8,7,6,5,4,5,6,7,8 }
};

int wall[10][10] = { {1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1},
		 	 						{1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1},
									{1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1},
									{1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1},
									{1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1},
									{1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1},
									{1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1},
									{1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1},
									{1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1},
									{1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1}
};

struct tStackElement
{
	int value;
} tStackElement;

struct tStack
{
	tStackElement elements[MAX_PEG_SIZE];
	int size;
} tStack;

tStack stackone,stacktwo;

bool push(tStack *stack, int value);
int pop(tStack *stack);
void initStack(tStack *stack);

bool push(tStack *stack, int value)
{
	if (isFull(stack))
	{
		return false;
	}
	stack->elements[stack->size++].value = value;
	return true;
}

int pop(tStack *stack)
{
	if (isEmpty(stack))
	{
		return 0;
	}
	return stack->elements[--stack->size].value;
}

void initStack(tStack *stack)
{
	stack->size = 0;
	memset(stack->elements, 0, sizeof(stack->elements));
}

void forward(int i){
	resetGyro(S3);
	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);

	int gyro = 0;
	int error , last_error , sum_error = 0;
	int encoder_L =  0;
	int encoder_R = 0;
	int avg_encoder = 0
	int pid = 0;

	while(avg_encoder < 620){
		encoder_L = getMotorEncoder(MotorD);
		encoder_R = getMotorEncoder(MotorA);
		Ultra_R = SensorValue[S1];
		Ultra_L = SensorValue[S4];
		gyro = getGyroDegrees(S3);
		last_error = error;

		if(i == 6){
			error = (Ultra_L - Ultra_R) >= 1 ? 1:error;
			error = (Ultra_L - Ultra_R) < 0 ? -1:error;
			pid = gyro*1 + error*1.5;
		}else{
			pid = 0;
		}

		sum_error+=error;
		avg_encoder = (encoder_L + encoder_R) / 2;
		//displayTextLine(0,"%d",encoder_L);
		//displayTextLine(1,"%d",encoder_R);
		pid = pid > 5 ? 5:pid;
		setMotorSpeed(motorA, 30+pid);
		setMotorSpeed(motorD, 30+pid*(-1));
	}
	setMotorSpeed(motorA, 0);
	setMotorSpeed(motorD, 0);

}

void turn_left(){
	int gyro,pid;

	for(int i = 0 ; i < 5000 ; i++){
		gyro = 90 + getGyroDegrees(S3);
		pid = gyro*0.5;
		setMotorSpeed(motorA, pid);
		setMotorSpeed(motorD, pid*(-1));
	}

}

void turn_right(){
	int gyro,pid;
	for(int i = 0 ; i < 5000 ; i++){
		gyro = -90 + getGyroDegrees(S3);
		pid = gyro*0.5;
		setMotorSpeed(motorA, pid);
		setMotorSpeed(motorD, pid*(-1));
	}
}
int check_pattern(int i , int j , int k){

		if(i < 12){
			state_L = 1;
		}
		if(j < 12){
			state_R = 1;
		}
		if(k < 15){
			state_F = 1;
		}

		if(!state_L && !state_F && !state_R){
			return 0;
		}else if(!state_L && state_F && !state_R){
			return 1;
		}else if(state_L && !state_F && !state_R){
		  return 2;
		}else if(!state_L && !state_F && state_R){
			return 4;
  	}else if(state_L && state_F && !state_R){
		  return 3;
		}else if(!state_L && state_F && state_R){
			return 5;
		}else if(state_L && !state_F && state_R){
			return 6;
		}else{
			return 7;
		}
		state_L = 0;
		state_R = 0;
		state_F = 0;
}


task main()
{
	///////////////////////////////////////////
	initStack(&stackone);
	initStack(&stacktwo);
	resetGyro(S3);

	while(1){

		setMotorSpeed(motorC, 100);

		Ultra_R = SensorValue[S1];
		Ultra_L = SensorValue[S4];
		Ultra_F = SensorValue[S2];

		int i = check_pattern(Ultra_L,Ultra_R,Ultra_F);
		displayTextLine(0,"%d",check_pattern(Ultra_L,Ultra_R,Ultra_F));

		if(i == 6 || i == 2){
			forward(i);
			playTone(4000, 10);
		}else if(i == 3){
			turn_right();
			forward(i);
			playTone(4000, 10);
		}else if(i == 5 || i == 0){
			turn_left();
			forward(i);
			playTone(4000, 10);
		}
		state_L = 0;
		state_R = 0;
		state_F = 0;

	}

	//right();
	////////////////////////////////////////////

}
